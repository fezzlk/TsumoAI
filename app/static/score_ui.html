<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>麻雀 点数算出 PoC</title>
    <style>
      :root {
        --bg: #f5f1e8;
        --card: #fffdf8;
        --line: #d8ccb8;
        --text: #2f2a21;
        --accent: #0f766e;
        --accent-2: #115e59;
        --error: #b91c1c;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Hiragino Sans", "Noto Sans JP", sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 20% 10%, #fff7e3 0 18%, transparent 19%),
          radial-gradient(circle at 80% 0%, #e4f4ef 0 16%, transparent 17%),
          var(--bg);
      }
      .wrap {
        max-width: 1120px;
        margin: 24px auto;
        padding: 0 16px 40px;
      }
      h1 {
        margin: 0 0 14px;
        letter-spacing: 0.02em;
      }
      .grid {
        display: grid;
        gap: 16px;
        grid-template-columns: 1fr;
      }
      @media (min-width: 980px) {
        .grid {
          grid-template-columns: 1.25fr 1fr;
        }
      }
      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 8px 20px rgba(28, 28, 30, 0.04);
      }
      .card h2 {
        margin-top: 0;
        font-size: 1.08rem;
      }
      label { display: block; margin: 10px 0 4px; font-weight: 600; }
      input[type="text"], input[type="number"], select, textarea {
        width: 100%;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #fff;
      }
      textarea { min-height: 84px; }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .checks {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 8px;
        margin-top: 8px;
      }
      .check {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        background: #fff;
      }
      button {
        margin-top: 14px;
        border: 0;
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        color: #fff;
        border-radius: 10px;
        font-weight: 700;
        padding: 10px 16px;
        cursor: pointer;
      }
      pre {
        white-space: pre-wrap;
        background: #f8f9fb;
        border-radius: 10px;
        padding: 12px;
        border: 1px solid #e6e8ef;
        font-size: 0.92rem;
      }
      .hint { color: #5f5849; font-size: 0.9rem; }
      .error { color: var(--error); font-weight: 700; }
      .result-line { margin: 6px 0; }
      .badge-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin: 8px 0;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid #cbd5e1;
        background: #f8fafc;
        font-size: 0.82rem;
      }
      .badge-empty {
        color: #64748b;
        border-style: dashed;
      }
      .tile-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding: 8px;
        border: 1px solid #e6e8ef;
        border-radius: 10px;
        background: #fafbfd;
        min-height: 72px;
      }
      .tile-row img {
        width: 44px;
        height: auto;
        border-radius: 4px;
        border: 1px solid #d7dce8;
        background: #fff;
      }
      .tile-fallback {
        width: 44px;
        height: 62px;
        border: 1px solid #cbd5e1;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        background: #fff;
      }
      .feedback-card {
        margin-top: 14px;
        padding: 12px;
        border: 1px solid #d5dbe7;
        border-radius: 10px;
        background: #fbfcff;
      }
      .feedback-title {
        margin: 0 0 8px;
        font-size: 0.98rem;
      }
      .feedback-status {
        margin-top: 8px;
        font-size: 0.88rem;
        color: #0b5f58;
      }
      .small {
        font-size: 0.84rem;
      }
      .pattern-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin: 8px 0 12px;
      }
      .pattern-item {
        border: 1px solid #d8dfeb;
        border-radius: 10px;
        padding: 8px 10px;
        background: #fff;
      }
      .hidden { display: none !important; }
      .disabled-block {
        opacity: 0.45;
        pointer-events: none;
      }
      .section-block {
        border: 1px solid #d8dfeb;
        border-radius: 10px;
        padding: 10px;
        background: #fff;
        margin-bottom: 10px;
      }
      .meld-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 8px;
      }
      .slot-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 8px;
      }
      .tile-slot-btn {
        margin-top: 0;
        background: #334155;
        padding: 6px;
        border-radius: 8px;
        min-width: 54px;
        min-height: 70px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .tile-slot-btn img {
        width: 36px;
        height: auto;
      }
      .winning-tile-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding: 8px;
        border: 1px solid #e6e8ef;
        border-radius: 10px;
        background: #fafbfd;
        min-height: 72px;
        margin-top: 6px;
      }
      .winning-tile-btn {
        margin-top: 0;
        border: 2px solid #cbd5e1;
        background: #fff;
        border-radius: 8px;
        padding: 4px;
        min-width: 44px;
        min-height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .winning-tile-btn.selected {
        border-color: #0f766e;
        box-shadow: 0 0 0 2px rgba(15, 118, 110, 0.2);
      }
      .winning-tile-btn img {
        width: 34px;
        height: auto;
      }
      .pair-tiles {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2px;
      }
      .pair-tiles img {
        width: 24px;
        height: auto;
      }
      .tile-slot-btn.empty {
        color: #d1d5db;
        font-size: 0.72rem;
      }
      .pair-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 8px;
      }
      .picker-modal {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 12px;
        z-index: 1200;
      }
      .picker-modal.open { display: flex; }
      .picker-panel {
        width: min(940px, 100%);
        max-height: 88vh;
        overflow: auto;
        padding: 12px;
        border: 1px solid #d9dde7;
        border-radius: 12px;
        background: #fcfdff;
        box-shadow: 0 18px 48px rgba(15, 23, 42, 0.18);
      }
      .picker-grid {
        display: grid;
        grid-template-columns: repeat(10, minmax(34px, 1fr));
        gap: 6px;
      }
      .picker-btn {
        border: 1px solid #d0d7e2;
        border-radius: 8px;
        background: #fff;
        padding: 2px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 54px;
      }
      .picker-btn img { width: 32px; }
      .option-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .option-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        background: #fff;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .dora-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .mini-btn {
        margin-top: 0;
        padding: 6px 8px;
        border-radius: 8px;
        background: #64748b;
        font-size: 0.8rem;
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <h1>麻雀 点数算出モジュール</h1>
      <p class="hint">牌姿と補完情報を入力し、<code>/api/v1/score</code> を呼び出します。</p>
      <div class="grid">
        <section class="card">
          <h2>入力</h2>

          <label>和了形</label>
          <div id="tileInputArea">
          <div class="pattern-row">
            <label class="pattern-item"><input type="radio" name="handPattern" value="standard" checked /> 4面子1雀頭</label>
            <label class="pattern-item"><input type="radio" name="handPattern" value="chiitoi" /> 七対子</label>
            <label class="pattern-item"><input type="radio" name="handPattern" value="kokushi" /> 国士無双</label>
          </div>

          <div id="patternStandard" class="section-block">
            <div class="meld-grid" id="standardMelds"></div>
          </div>

          <div id="patternChiitoi" class="section-block hidden">
            <label>対子 x 7</label>
            <div class="pair-grid" id="chiitoiPairs"></div>
          </div>

          <div id="patternKokushi" class="section-block hidden">
            <label>対子（国士無双）</label>
            <div class="slot-row">
              <button type="button" class="tile-slot-btn empty" id="kokushiPairBtn">対子</button>
            </div>
            <p class="hint">構成牌は国士無双13種から、選択した対子1種を重ねた14枚になります。</p>
          </div>
          </div>

          <div id="winningTileBlock">
            <label for="winningTileRow">入力牌（クリックで上がり牌を選択）</label>
            <div id="winningTileRow" class="winning-tile-row"></div>
            <p class="hint">牌入力で組んだ14〜18枚から上がり牌を選択します。選択中の牌は枠で表示されます。</p>
          </div>

          <label class="pattern-item" style="display:inline-flex;align-items:center;gap:8px;margin-bottom:10px;">
            <input type="checkbox" id="jsonDirectSwitch" />
            JSON直接入力
          </label>
          <label for="handJsonInput">手牌JSON（closed_tiles / melds / win_tile）</label>
          <textarea id="handJsonInput" disabled></textarea>
          <p class="hint">JSON直接入力ONで編集可能。OFF時は牌入力フォーム状態で自動上書きされます。</p>

          <label>和了方法</label>
          <div class="option-group">
            <label class="option-item"><input type="radio" name="winType" value="ron" checked /> ロン</label>
            <label class="option-item"><input type="radio" name="winType" value="tsumo" /> ツモ</label>
          </div>

          <label>親子</label>
          <div class="option-group">
            <label class="option-item"><input type="radio" name="isDealer" value="false" checked /> 子</label>
            <label class="option-item"><input type="radio" name="isDealer" value="true" /> 親</label>
          </div>

          <label>場風</label>
          <div class="option-group">
            <label class="option-item"><input type="radio" name="roundWind" value="E" checked /> 東</label>
            <label class="option-item"><input type="radio" name="roundWind" value="S" /> 南</label>
            <label class="option-item"><input type="radio" name="roundWind" value="W" /> 西</label>
            <label class="option-item"><input type="radio" name="roundWind" value="N" /> 北</label>
          </div>

          <label>自風</label>
          <div class="option-group">
            <label class="option-item"><input type="radio" name="seatWind" value="E" /> 東</label>
            <label class="option-item"><input type="radio" name="seatWind" value="S" checked /> 南</label>
            <label class="option-item"><input type="radio" name="seatWind" value="W" /> 西</label>
            <label class="option-item"><input type="radio" name="seatWind" value="N" /> 北</label>
          </div>

          <label>ドラ入力モード</label>
          <div class="option-group">
            <label class="option-item"><input type="radio" name="doraMode" value="dora" checked /> ドラ入力</label>
            <label class="option-item"><input type="radio" name="doraMode" value="indicator" /> ドラ表示牌入力</label>
          </div>

          <div id="doraTilesBlock">
            <label>ドラ牌</label>
            <div id="doraTileRow" class="slot-row"></div>
            <button id="addDoraTileBtn" type="button" class="mini-btn">ドラ牌を追加</button>
            <label>裏ドラ牌</label>
            <div id="uraDoraTileRow" class="slot-row"></div>
            <button id="addUraDoraTileBtn" type="button" class="mini-btn">裏ドラ牌を追加</button>
          </div>

          <div id="doraIndicatorsBlock" class="hidden">
            <label>ドラ表示牌</label>
            <div id="doraIndicatorRow" class="slot-row"></div>
            <button id="addDoraIndicatorBtn" type="button" class="mini-btn">ドラ表示牌を追加</button>
            <label>裏ドラ表示牌</label>
            <div id="uraDoraIndicatorRow" class="slot-row"></div>
            <button id="addUraDoraIndicatorBtn" type="button" class="mini-btn">裏ドラ表示牌を追加</button>
          </div>

          <div class="row">
            <div>
              <label for="honba">本場</label>
              <input id="honba" type="number" min="0" value="0" />
            </div>
            <div>
              <label for="kyotaku">供託（リーチ棒本数）</label>
              <input id="kyotaku" type="number" min="0" value="0" />
            </div>
          </div>

          <label>連風符</label>
          <div class="option-group">
            <label class="option-item"><input type="radio" name="renpuFu" value="4" checked /> 4符</label>
            <label class="option-item"><input type="radio" name="renpuFu" value="2" /> 2符</label>
          </div>

          <label>フラグ</label>
          <div class="checks">
            <label class="check" style="grid-column: 1 / -1;">
              <span style="display:block;margin-bottom:4px;">立直</span>
              <label style="margin:0 10px 0 0;font-weight:400;"><input type="radio" name="riichiState" value="none" checked /> なし</label>
              <label style="margin:0 10px 0 0;font-weight:400;"><input type="radio" name="riichiState" value="riichi" /> リーチ</label>
              <label style="margin:0;font-weight:400;"><input type="radio" name="riichiState" value="double" /> ダブルリーチ</label>
            </label>
            <label class="check"><input id="ippatsu" type="checkbox" /> 一発</label>
            <label class="check"><input id="haitei" type="checkbox" /> 海底</label>
            <label class="check"><input id="houtei" type="checkbox" /> 河底</label>
            <label class="check"><input id="rinshan" type="checkbox" /> 嶺上</label>
            <label class="check"><input id="chankan" type="checkbox" /> 槍槓</label>
            <label class="check"><input id="chiihou" type="checkbox" /> 地和</label>
            <label class="check"><input id="tenhou" type="checkbox" /> 天和</label>
          </div>

          <button id="submitBtn">点数を算出</button>
          <div id="error" class="error"></div>
        </section>

        <section class="card">
          <h2>結果</h2>
          <div id="summary"></div>
          <label>レスポンスJSON</label>
          <button id="toggleResponseJsonBtn" type="button" class="mini-btn">開く</button>
          <pre id="responseJson" class="hidden"></pre>

          <div class="feedback-card">
            <p class="feedback-title">誤り指摘（GCS保存）</p>
            <p class="hint small">算出結果が誤っている場合、自然言語でコメントを入力して送信してください。</p>
            <label for="feedbackComment">コメント</label>
            <textarea id="feedbackComment" placeholder="例: 立直のみで一発は付かないはず"></textarea>
            <button id="sendFeedbackBtn" type="button">コメントを送信</button>
            <div id="feedbackStatus" class="feedback-status"></div>
          </div>
        </section>
      </div>
    </main>

    <div id="tilePickerModal" class="picker-modal">
      <div class="picker-panel">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
          <strong>牌を選択</strong>
          <button id="closeTilePickerBtn" type="button" style="margin-top:0;background:#64748b;">中断</button>
        </div>
        <div id="tilePickerTarget" class="hint" style="margin:6px 0 10px;"></div>
        <div id="tilePickerGrid" class="picker-grid"></div>
      </div>
    </div>

    <script>
      const KOKUSHI_TILES = ["1m","9m","1p","9p","1s","9s","E","S","W","N","P","F","C"];
      const TILE_LIST = [
        "1m","2m","3m","4m","5m","6m","7m","8m","9m","5mr",
        "1p","2p","3p","4p","5p","6p","7p","8p","9p","5pr",
        "1s","2s","3s","4s","5s","6s","7s","8s","9s","5sr",
        "E","S","W","N","P","F","C"
      ];

      function value(id) { return document.getElementById(id).value; }
      function checked(id) { return document.getElementById(id).checked; }
      function toInt(id) { return Number.parseInt(value(id), 10) || 0; }
      function radioValue(name) {
        const checkedInput = document.querySelector(`input[name="${name}"]:checked`);
        return checkedInput ? checkedInput.value : "";
      }

      function tileToFilename(tileCode) {
        const t = tileCode.trim();
        if (/^5[smpr]r$/.test(t)) return `Mpu0${t[1]}.png`;
        if (/^[1-9][mps]$/.test(t)) return `Mpu${t[0]}${t[1]}.png`;
        const honors = { E: "1", S: "2", W: "3", N: "4", P: "5", F: "6", C: "7" };
        if (honors[t]) return `Mpu${honors[t]}z.png`;
        return null;
      }

      class TilePickerModalComponent {
        constructor(modalId, gridId, targetId, closeBtnId) {
          this.modal = document.getElementById(modalId);
          this.grid = document.getElementById(gridId);
          this.target = document.getElementById(targetId);
          this.closeBtn = document.getElementById(closeBtnId);
          this.selectHandler = null;
          this._renderGrid();
          this.closeBtn.addEventListener("click", () => this.close());
          this.modal.addEventListener("click", (e) => {
            if (e.target === this.modal) this.close();
          });
        }

        _renderGrid() {
          this.grid.innerHTML = "";
          TILE_LIST.forEach((tile) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "picker-btn";
            btn.title = tile;
            const filename = tileToFilename(tile);
            if (filename) {
              const img = document.createElement("img");
              img.src = `/static/tiles/${filename}`;
              img.alt = tile;
              btn.appendChild(img);
            } else {
              btn.textContent = tile;
            }
            btn.addEventListener("click", () => {
              if (this.selectHandler) this.selectHandler(tile);
              this.close();
            });
            this.grid.appendChild(btn);
          });
        }

        open(targetText, onSelect) {
          this.target.textContent = targetText;
          this.selectHandler = onSelect;
          this.modal.classList.add("open");
        }

        close() {
          this.selectHandler = null;
          this.modal.classList.remove("open");
        }
      }

      const picker = new TilePickerModalComponent("tilePickerModal", "tilePickerGrid", "tilePickerTarget", "closeTilePickerBtn");

      const uiState = {
        pattern: "standard",
        jsonDirect: false,
        selectedWinTileIndex: null,
        doraMode: "dora",
        handJsonFromTiles: { closed_tiles: [], melds: [], win_tile: "" },
        doraTiles: ["4m"],
        uraDoraTiles: [],
        doraIndicators: ["4m"],
        uraDoraIndicators: [],
        standard: {
          melds: [
            { type: "concealed", tiles: ["1m", "2m", "3m", null] },
            { type: "concealed", tiles: ["4p", "5p", "6p", null] },
            { type: "concealed", tiles: ["7s", "8s", "9s", null] },
            { type: "concealed", tiles: ["E", "E", "E", null] }
          ],
          pair: "2p"
        },
        chiitoi: { pairs: Array.from({ length: 7 }, () => null) },
        kokushi: { pair: null }
      };

      function openPickerForPair(targetKey, label) {
        picker.open(label, (tile) => {
          targetKey.setter(tile);
          renderAllPatternInputs();
        });
      }

      function setSlotButtonContent(btn, tile) {
        btn.classList.toggle("empty", !tile);
        btn.innerHTML = "";
        if (!tile) {
          btn.textContent = "未選択";
          return;
        }
        const filename = tileToFilename(tile);
        if (!filename) {
          btn.textContent = tile;
          return;
        }
        const img = document.createElement("img");
        img.src = `/static/tiles/${filename}`;
        img.alt = tile;
        btn.appendChild(img);
      }

      function setPairButtonContent(btn, tile) {
        btn.classList.toggle("empty", !tile);
        btn.innerHTML = "";
        if (!tile) {
          btn.textContent = "未選択";
          return;
        }
        const filename = tileToFilename(tile);
        if (!filename) {
          btn.textContent = `${tile}${tile}`;
          return;
        }
        const wrap = document.createElement("div");
        wrap.className = "pair-tiles";
        for (let i = 0; i < 2; i += 1) {
          const img = document.createElement("img");
          img.src = `/static/tiles/${filename}`;
          img.alt = tile;
          wrap.appendChild(img);
        }
        btn.appendChild(wrap);
      }

      function requiredMeldLen(type) {
        return ["kan", "ankan", "kakan"].includes(type) ? 4 : 3;
      }

      function renderDoraList(rootId, list, labelPrefix, fallbackTile) {
        const root = document.getElementById(rootId);
        root.innerHTML = "";
        list.forEach((tile, idx) => {
          const item = document.createElement("div");
          item.className = "dora-item";

          const pickBtn = document.createElement("button");
          pickBtn.type = "button";
          pickBtn.className = "tile-slot-btn";
          setSlotButtonContent(pickBtn, tile);
          pickBtn.addEventListener("click", () => {
            picker.open(`${labelPrefix}${idx + 1}`, (selected) => {
              list[idx] = selected;
              renderDoraInputs();
            });
          });
          item.appendChild(pickBtn);

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "mini-btn";
          delBtn.textContent = "削除";
          delBtn.disabled = list.length <= 1;
          delBtn.addEventListener("click", () => {
            list.splice(idx, 1);
            if (!list.length) list.push(fallbackTile);
            renderDoraInputs();
          });
          item.appendChild(delBtn);

          root.appendChild(item);
        });
      }

      function syncDoraModeFromUi() {
        uiState.doraMode = radioValue("doraMode") || "dora";
        document.getElementById("doraTilesBlock").classList.toggle("hidden", uiState.doraMode !== "dora");
        document.getElementById("doraIndicatorsBlock").classList.toggle("hidden", uiState.doraMode !== "indicator");
      }

      function renderDoraInputs() {
        renderDoraList("doraTileRow", uiState.doraTiles, "ドラ牌", "4m");
        renderDoraList("uraDoraTileRow", uiState.uraDoraTiles, "裏ドラ牌", "4m");
        renderDoraList("doraIndicatorRow", uiState.doraIndicators, "ドラ表示牌", "4m");
        renderDoraList("uraDoraIndicatorRow", uiState.uraDoraIndicators, "裏ドラ表示牌", "4m");
        syncDoraModeFromUi();
      }

      function flattenHandTiles(hand) {
        const out = [];
        (hand.closed_tiles || []).forEach((tile) => out.push(tile));
        (hand.melds || []).forEach((meld) => (meld.tiles || []).forEach((tile) => out.push(tile)));
        return out;
      }

      function renderWinningTileSelector() {
        const row = document.getElementById("winningTileRow");
        row.innerHTML = "";
        const tiles = flattenHandTiles(uiState.handJsonFromTiles);
        if (!tiles.length) {
          const empty = document.createElement("div");
          empty.className = "hint";
          empty.textContent = "牌を入力するとここに表示されます";
          row.appendChild(empty);
          return;
        }
        tiles.forEach((tile, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "winning-tile-btn";
          if (idx === uiState.selectedWinTileIndex) btn.classList.add("selected");
          const filename = tileToFilename(tile);
          if (filename) {
            const img = document.createElement("img");
            img.src = `/static/tiles/${filename}`;
            img.alt = tile;
            img.title = `上がり牌に選択: ${tile}`;
            btn.appendChild(img);
          } else {
            btn.textContent = tile;
          }
          btn.addEventListener("click", () => {
            uiState.selectedWinTileIndex = idx;
            uiState.handJsonFromTiles.win_tile = tile;
            if (!uiState.jsonDirect) {
              document.getElementById("handJsonInput").value = JSON.stringify(uiState.handJsonFromTiles, null, 2);
            }
            renderWinningTileSelector();
          });
          row.appendChild(btn);
        });
      }

      function applySelectedWinTile(hand) {
        const tiles = flattenHandTiles(hand);
        if (!tiles.length) {
          hand.win_tile = "";
          uiState.selectedWinTileIndex = null;
          return hand;
        }
        if (
          uiState.selectedWinTileIndex === null ||
          uiState.selectedWinTileIndex < 0 ||
          uiState.selectedWinTileIndex >= tiles.length
        ) {
          uiState.selectedWinTileIndex = tiles.length - 1;
        }
        hand.win_tile = tiles[uiState.selectedWinTileIndex];
        return hand;
      }

      function buildStandardMeldInputs() {
        const root = document.getElementById("standardMelds");
        root.innerHTML = "";
        uiState.standard.melds.forEach((m, idx) => {
          const block = document.createElement("div");
          block.className = "section-block";

          const title = document.createElement("label");
          title.textContent = `面子${idx + 1}`;
          block.appendChild(title);

          const sel = document.createElement("select");
          sel.innerHTML = `
            <option value="concealed">副露なし</option>
            <option value="pon">碰（ポン）</option>
            <option value="chi">吃（チー）</option>
            <option value="ankan">暗槓（アンカン）</option>
            <option value="kan">明槓（ミンカン）</option>
          `;
          sel.value = m.type;
          sel.addEventListener("change", () => {
            m.type = sel.value;
            if (requiredMeldLen(m.type) === 3) m.tiles[3] = null;
            renderAllPatternInputs();
          });
          block.appendChild(sel);

          const row = document.createElement("div");
          row.className = "slot-row";
          const needed = requiredMeldLen(m.type);
          for (let i = 0; i < 4; i += 1) {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "tile-slot-btn";
            if (i >= needed) b.classList.add("hidden");
            setSlotButtonContent(b, m.tiles[i]);
            b.addEventListener("click", () => {
              picker.open(`面子${idx + 1} 牌${i + 1}`, (tile) => {
                m.tiles[i] = tile;
                renderAllPatternInputs();
              });
            });
            row.appendChild(b);
          }
          block.appendChild(row);
          root.appendChild(block);
        });

        const pairBlock = document.createElement("div");
        pairBlock.className = "section-block";
        const pairTitle = document.createElement("label");
        pairTitle.textContent = "雀頭";
        pairBlock.appendChild(pairTitle);
        const pairRow = document.createElement("div");
        pairRow.className = "slot-row";
        const pairBtn = document.createElement("button");
        pairBtn.type = "button";
        pairBtn.className = "tile-slot-btn";
        setPairButtonContent(pairBtn, uiState.standard.pair);
        pairBtn.addEventListener("click", () => {
          picker.open("4面子1雀頭 雀頭", (tile) => {
            uiState.standard.pair = tile;
            renderAllPatternInputs();
          });
        });
        pairRow.appendChild(pairBtn);
        pairBlock.appendChild(pairRow);
        root.appendChild(pairBlock);
      }

      function renderPairButton(id, tile, label, setter) {
        const btn = document.getElementById(id);
        setPairButtonContent(btn, tile);
        btn.onclick = () => openPickerForPair({ setter }, label);
      }

      function buildChiitoiInputs() {
        const root = document.getElementById("chiitoiPairs");
        root.innerHTML = "";
        uiState.chiitoi.pairs.forEach((tile, i) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = "tile-slot-btn";
          setPairButtonContent(b, tile);
          b.onclick = () => {
            picker.open(`七対子 対子${i + 1}`, (selected) => {
              uiState.chiitoi.pairs[i] = selected;
              renderAllPatternInputs();
            });
          };
          root.appendChild(b);
        });
      }

      function switchPattern(pattern) {
        uiState.pattern = pattern;
        document.getElementById("patternStandard").classList.toggle("hidden", pattern !== "standard");
        document.getElementById("patternChiitoi").classList.toggle("hidden", pattern !== "chiitoi");
        document.getElementById("patternKokushi").classList.toggle("hidden", pattern !== "kokushi");
        renderAllPatternInputs();
        syncHandJsonFromState();
      }

      function renderAllPatternInputs() {
        buildStandardMeldInputs();
        buildChiitoiInputs();
        renderPairButton("kokushiPairBtn", uiState.kokushi.pair, "国士無双 対子", (tile) => {
          uiState.kokushi.pair = tile;
        });
        syncHandJsonFromState();
        refreshSubmitAvailability();
      }

      function setTileInputEnabled(enabled) {
        const root = document.getElementById("tileInputArea");
        root.classList.toggle("disabled-block", !enabled);
        const controls = root.querySelectorAll("button, select, input[type='radio']");
        controls.forEach((el) => {
          el.disabled = !enabled;
        });
        const winningBlock = document.getElementById("winningTileBlock");
        winningBlock.classList.toggle("disabled-block", !enabled);
        const winningControls = winningBlock.querySelectorAll("button");
        winningControls.forEach((el) => {
          el.disabled = !enabled;
        });
        if (!enabled) picker.close();
      }

      function buildHandByPatternState() {
        if (uiState.pattern === "standard") {
          if (!uiState.standard.pair) throw new Error("対子を入力してください");
          const closedTiles = [uiState.standard.pair, uiState.standard.pair];
          const melds = [];
          for (const meld of uiState.standard.melds) {
            const need = requiredMeldLen(meld.type);
            const tiles = meld.tiles.slice(0, need);
            if (tiles.some((t) => !t)) throw new Error("4面子1雀頭の面子牌が不足しています");
            if (meld.type === "concealed") {
              closedTiles.push(...tiles);
            } else {
              melds.push({ type: meld.type, tiles, open: meld.type !== "ankan" });
            }
          }
          const kanCount = melds.filter((m) => ["kan", "ankan", "kakan"].includes(m.type)).length;
          const total = closedTiles.length + melds.reduce((n, m) => n + m.tiles.length, 0);
          const expectedTotal = 14 + kanCount;
          if (total !== expectedTotal) {
            throw new Error(`牌数が${expectedTotal}枚になっていません`);
          }
          return applySelectedWinTile({ closed_tiles: closedTiles, melds, win_tile: "" });
        }

        if (uiState.pattern === "chiitoi") {
          if (uiState.chiitoi.pairs.some((p) => !p)) throw new Error("七対子の対子が不足しています");
          const closedTiles = [];
          uiState.chiitoi.pairs.forEach((p) => {
            closedTiles.push(p, p);
          });
          return applySelectedWinTile({ closed_tiles: closedTiles, melds: [], win_tile: "" });
        }

        if (!uiState.kokushi.pair) throw new Error("国士無双の対子を入力してください");
        if (!KOKUSHI_TILES.includes(uiState.kokushi.pair.replace("r", ""))) {
          throw new Error("国士無双の対子は么九牌/字牌を選んでください");
        }
        const pairTile = uiState.kokushi.pair;
        const base = [...KOKUSHI_TILES];
        const closedTiles = [...base, pairTile];
        return applySelectedWinTile({ closed_tiles: closedTiles, melds: [], win_tile: "" });
      }

      function buildHandDraftByPatternState() {
        if (uiState.pattern === "standard") {
          const closedTiles = [];
          const melds = [];
          if (uiState.standard.pair) {
            closedTiles.push(uiState.standard.pair, uiState.standard.pair);
          }
          for (const meld of uiState.standard.melds) {
            const need = requiredMeldLen(meld.type);
            const tiles = meld.tiles.slice(0, need).filter(Boolean);
            if (meld.type === "concealed") {
              closedTiles.push(...tiles);
            } else {
              melds.push({ type: meld.type, tiles, open: meld.type !== "ankan" });
            }
          }
          return applySelectedWinTile({
            closed_tiles: closedTiles,
            melds,
            win_tile: closedTiles[closedTiles.length - 1] || ""
          });
        }

        if (uiState.pattern === "chiitoi") {
          const closedTiles = [];
          uiState.chiitoi.pairs.forEach((p) => {
            if (p) closedTiles.push(p, p);
          });
          return applySelectedWinTile({ closed_tiles: closedTiles, melds: [], win_tile: "" });
        }

        const closedTiles = [...KOKUSHI_TILES];
        if (uiState.kokushi.pair) closedTiles.push(uiState.kokushi.pair);
        return applySelectedWinTile({ closed_tiles: closedTiles, melds: [], win_tile: "" });
      }

      function syncHandJsonFromState() {
        try {
          uiState.handJsonFromTiles = buildHandByPatternState();
        } catch {
          uiState.handJsonFromTiles = buildHandDraftByPatternState();
        }
        renderWinningTileSelector();

        if (uiState.jsonDirect) return;
        const box = document.getElementById("handJsonInput");
        box.value = JSON.stringify(uiState.handJsonFromTiles, null, 2);
      }

      function writeHandJsonFromStoredState() {
        const box = document.getElementById("handJsonInput");
        try {
          box.value = JSON.stringify(uiState.handJsonFromTiles, null, 2);
        } catch {
          box.value = "";
        }
      }

      function readHandFromJsonInput() {
        let parsed;
        try {
          parsed = JSON.parse(value("handJsonInput"));
        } catch {
          throw new Error("手牌JSONの形式が不正です");
        }
        if (!parsed || typeof parsed !== "object") throw new Error("手牌JSONはオブジェクトで入力してください");
        if (!Array.isArray(parsed.closed_tiles)) throw new Error("手牌JSON: closed_tiles は配列が必要です");
        if (!Array.isArray(parsed.melds)) throw new Error("手牌JSON: melds は配列が必要です");
        if (!parsed.win_tile || typeof parsed.win_tile !== "string") throw new Error("手牌JSON: win_tile は文字列が必要です");
        return parsed;
      }

      function buildHandByPattern() {
        return uiState.jsonDirect ? readHandFromJsonInput() : buildHandByPatternState();
      }

      function buildPayload() {
        const hand = buildHandByPattern();
        const activeDoraValues = (uiState.doraMode === "indicator" ? uiState.doraIndicators : uiState.doraTiles).filter(Boolean);
        const activeUraDoraValues = (uiState.doraMode === "indicator" ? uiState.uraDoraIndicators : uiState.uraDoraTiles).filter(Boolean);
        const riichiState = radioValue("riichiState") || "none";
        return {
          hand,
          context: {
            win_type: radioValue("winType"),
            is_dealer: radioValue("isDealer") === "true",
            round_wind: radioValue("roundWind"),
            seat_wind: radioValue("seatWind"),
            riichi: riichiState === "riichi",
            double_riichi: riichiState === "double",
            ippatsu: checked("ippatsu"),
            haitei: checked("haitei"),
            houtei: checked("houtei"),
            rinshan: checked("rinshan"),
            chankan: checked("chankan"),
            chiihou: checked("chiihou"),
            tenhou: checked("tenhou"),
            dora_indicators: activeDoraValues,
            ura_dora_indicators: activeUraDoraValues,
            aka_dora_count: 0,
            honba: toInt("honba"),
            kyotaku: toInt("kyotaku")
          },
          rules: {
            aka_ari: true,
            kuitan_ari: true,
            double_yakuman_ari: true,
            kazoe_yakuman_ari: true,
            renpu_fu: Number.parseInt(radioValue("renpuFu"), 10) || 4
          }
        };
      }

      function refreshSubmitAvailability() {
        const submitBtn = document.getElementById("submitBtn");
        const error = document.getElementById("error");
        try {
          buildPayload();
          submitBtn.disabled = false;
          if (error.dataset.validation === "1") {
            error.textContent = "";
            error.dataset.validation = "0";
          }
        } catch (e) {
          submitBtn.disabled = true;
          error.textContent = e.message || "入力エラーがあります";
          error.dataset.validation = "1";
        }
      }

      let lastScoreRequest = null;
      let lastScoreResponse = null;
      let responseJsonExpanded = false;

      async function submitScore() {
        const error = document.getElementById("error");
        error.textContent = "";
        document.getElementById("summary").innerHTML = "";

        let payload;
        try {
          payload = buildPayload();
        } catch (e) {
          error.textContent = e.message;
          return;
        }

        lastScoreRequest = payload;

        const res = await fetch("/api/v1/score", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        document.getElementById("responseJson").textContent = JSON.stringify(data, null, 2);
        lastScoreResponse = data;

        if (!res.ok) {
          error.textContent = data.detail || "API呼び出しに失敗しました";
          return;
        }

        const r = data.result;
        const yakuBadges = (r.yaku || []).map((y) => `<span class="badge">${y.name} ${y.han}翻</span>`).join("");
        const yakumanBadges = (r.yakuman || []).map((name) => `<span class="badge">${name}</span>`).join("");
        const roleBadgeHtml =
          yakuBadges || yakumanBadges
            ? `<div class="badge-row">${yakuBadges}${yakumanBadges}</div>`
            : `<div class="badge-row"><span class="badge badge-empty">役なし</span></div>`;
        document.getElementById("summary").innerHTML = `
          <div class="result-line"><strong>${r.point_label}</strong></div>
          ${roleBadgeHtml}
          <div class="result-line">翻: ${r.han} / 符: ${r.fu}</div>
          <div class="result-line">ロン: ${r.points.ron}</div>
          <div class="result-line">ツモ(親支払): ${r.points.tsumo_dealer_pay}</div>
          <div class="result-line">ツモ(子支払): ${r.points.tsumo_non_dealer_pay}</div>
          <div class="result-line">受取合計: ${r.payments.total_received}</div>
        `;
      }

      async function sendFeedback() {
        const status = document.getElementById("feedbackStatus");
        status.textContent = "";
        if (!lastScoreRequest || !lastScoreResponse || !lastScoreResponse.result) {
          status.textContent = "先に点数算出を実行してください。";
          return;
        }
        const comment = value("feedbackComment").trim();
        if (!comment) {
          status.textContent = "コメントを入力してください。";
          return;
        }
        const payload = {
          score_request: lastScoreRequest,
          score_response: lastScoreResponse,
          comment
        };
        const res = await fetch("/api/v1/score/feedback", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) {
          status.textContent = `送信失敗: ${data.detail || "unknown error"}`;
          return;
        }
        status.textContent = `送信完了: gs://${data.storage.bucket}/${data.storage.object_name}`;
      }

      document.querySelectorAll('input[name="handPattern"]').forEach((el) => {
        el.addEventListener("change", () => switchPattern(el.value));
      });
      document.getElementById("jsonDirectSwitch").addEventListener("change", (e) => {
        const on = e.target.checked;
        uiState.jsonDirect = on;
        document.getElementById("handJsonInput").disabled = !on;
        setTileInputEnabled(!on);
        if (!on) writeHandJsonFromStoredState();
        refreshSubmitAvailability();
      });
      document.getElementById("handJsonInput").addEventListener("input", refreshSubmitAvailability);
      document.querySelectorAll('input[name="doraMode"]').forEach((el) => {
        el.addEventListener("change", () => {
          syncDoraModeFromUi();
          refreshSubmitAvailability();
        });
      });
      document.querySelectorAll('input[name="riichiState"]').forEach((el) => {
        el.addEventListener("change", refreshSubmitAvailability);
      });
      document.getElementById("addDoraTileBtn").addEventListener("click", () => {
        uiState.doraTiles.push(null);
        renderDoraInputs();
        refreshSubmitAvailability();
      });
      document.getElementById("addUraDoraTileBtn").addEventListener("click", () => {
        uiState.uraDoraTiles.push(null);
        renderDoraInputs();
        refreshSubmitAvailability();
      });
      document.getElementById("addDoraIndicatorBtn").addEventListener("click", () => {
        uiState.doraIndicators.push(null);
        renderDoraInputs();
        refreshSubmitAvailability();
      });
      document.getElementById("addUraDoraIndicatorBtn").addEventListener("click", () => {
        uiState.uraDoraIndicators.push(null);
        renderDoraInputs();
        refreshSubmitAvailability();
      });
      document.getElementById("submitBtn").addEventListener("click", submitScore);
      document.getElementById("sendFeedbackBtn").addEventListener("click", sendFeedback);
      document.getElementById("toggleResponseJsonBtn").addEventListener("click", () => {
        responseJsonExpanded = !responseJsonExpanded;
        document.getElementById("responseJson").classList.toggle("hidden", !responseJsonExpanded);
        document.getElementById("toggleResponseJsonBtn").textContent = responseJsonExpanded ? "閉じる" : "開く";
      });

      switchPattern("standard");
      renderDoraInputs();
      syncHandJsonFromState();
      refreshSubmitAvailability();
      submitScore();
    </script>
  </body>
</html>
